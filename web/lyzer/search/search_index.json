{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Lyzer \ud83c\udfce\ufe0f\ud83d\udcca","text":"<p>A Formula 1 Data Analysis Tool (Work in Progress) </p> <p>Lyzer is a passion project aimed at bringing Formula 1 enthusiasts closer to the data. While still in its early stages, Lyzer is designed to analyze and compare Formula 1 statistics, providing insights for fans, analysts, and data enthusiasts alike.  </p>"},{"location":"#current-status","title":"\ud83d\udea7 Current Status","text":"<p>This project is under active development and is not yet production-ready. Lyzer combines a dedicated C# backend with a React frontend to build a fast and flexible tool for exploring the world of Formula 1 data.  </p>"},{"location":"#features-planned","title":"\ud83c\udfaf Features (Planned)","text":"<p>Although it's early days, here\u2019s what Lyzer might offer in the future: - Analysis of Formula 1 races, teams, and drivers. - Comparison of statistics across seasons, races, and drivers. - Visualization tools for making sense of the data.  </p>"},{"location":"#why-lyzer","title":"\ud83d\udca1 Why Lyzer?","text":"<p>\"Lyzer\" (from analyzer or analyzing) reflects the essence of what we aim to achieve\u2014diving deep into the numbers and uncovering insights for Formula 1 fans.  </p>"},{"location":"#tech-stack","title":"\u2699\ufe0f Tech Stack","text":"<ul> <li>Backend: C#  </li> <li>Frontend: React, Typescript</li> </ul>"},{"location":"#contributing","title":"\ud83c\udf1f Contributing","text":"<p>As Lyzer evolves, we welcome ideas, feedback, and contributions from the community. Feel free to open an issue or submit a pull request to help shape the project\u2019s future.  </p>"},{"location":"#future-goals","title":"\ud83d\ude80 Future Goals","text":"<p>Lyzer is a hobby project with the aspiration of one day going live. While we\u2019re taking it step by step, our goal is to build something useful, engaging, and impactful for the Formula 1 community.  </p>"},{"location":"backend/architecture/","title":"General Structure of the API/Backend","text":"<p>The primary components to be aware of in the backend are:</p> <ul> <li>Controllers</li> <li>Services</li> <li>Clients</li> <li>Repositories</li> </ul> <p>There are also other components that play a less pivotal role but still form part of the project, such as:</p> <ul> <li>Constants</li> <li>DTOs</li> <li>Middleware</li> <li>Errors</li> </ul>"},{"location":"backend/architecture/#controllers","title":"Controllers","text":"<p>The controllers are the entry point to the API from a consumer perspective. This is where endpoints are declared and exposed to the consumer.</p> <p>They are primarily responsible for routing and should be as simple as possible. They call the relevant services to handle business logic, data retrieval, etc.</p> <p>An example of a controller is shown below:</p> <pre><code>using Lyzer.Common.DTO;\nusing Lyzer.Services;\nusing Microsoft.AspNetCore.Mvc;\nusing System.Text.Json;\n\nnamespace Lyzer.Controllers\n{\n    [ApiController]\n    [Route(\"/api/v1/drivers\")]\n    public class DriverController : ControllerBase\n    {\n        private readonly ILogger&lt;DriverController&gt; _logger;\n        private readonly DriverService _driverService;\n\n        public DriverController(ILogger&lt;DriverController&gt; logger, DriverService driverService)\n        {\n            _logger = logger;\n            _driverService = driverService;\n        }\n\n        [HttpGet(\"standings\", Name = \"Get driver standings\")]\n        public async Task&lt;ActionResult&lt;DriverStandingsDTO&gt;&gt; GetCurrentDriverStandings()\n        {\n            return await _driverService.GetCurrentDriverStandings();\n        }\n    }\n}\n</code></pre>"},{"location":"backend/architecture/#services","title":"Services","text":"<p>The services are likely the more complex and sophisticated pieces of the codebase, as this is where the heavy lifting occurs.</p> <p>Services are responsible for handling all business logic, transformation, and calling the relevant data retrieval methods/functionality.</p> <p>An example of a service is shown below:</p> <pre><code>using Lyzer.Clients;\nusing Lyzer.Common.Constants;\nusing Lyzer.Common.DTO;\nusing Newtonsoft.Json;\n\nnamespace Lyzer.Services\n{\n    public class DriverService\n    {\n        private readonly ILogger&lt;DriverService&gt; _logger;\n        private readonly JolpicaClient _client;\n        private readonly CacheService _cache;\n\n        public DriverService(ILogger&lt;DriverService&gt; logger, JolpicaClient client, CacheService cache)\n        {\n            _logger = logger;\n            _client = client;\n            _cache = cache;\n        }\n\n        public async Task&lt;DriverStandingsDTO&gt; GetCurrentDriverStandings()\n        {\n            string key = String.Format(CacheKeyConstants.DriverStandings, \"current\");\n            string? result = await _cache.Get(key);\n\n            if (result == null)\n            {\n                DriverStandingsDTO standings = await _client.GetCurrentDriverStandings();\n                await _cache.Add(key, JsonConvert.SerializeObject(standings), TimeSpan.FromHours(1));\n                return standings;\n            }\n\n            return JsonConvert.DeserializeObject&lt;DriverStandingsDTO&gt;(result) ?? new DriverStandingsDTO();\n        }\n    }\n}\n</code></pre>"},{"location":"backend/architecture/#clients","title":"Clients","text":"<p>Clients are responsible for communicating with other APIs. In the case of Lyzer, an example is a client to query Jolpica F1 data.</p> <p>Clients should perform minimal work, keeping everything as simple as possible, and focus primarily on communication with APIs. They should not perform transformations or similar tasks.</p> <p>An example implementation is shown below:</p> <pre><code>using System.Runtime.Serialization;\nusing System.Text.Json;\nusing Newtonsoft.Json;\nusing RestSharp;\nusing Lyzer.Common.Constants;\nusing Lyzer.Common.DTO;\nusing Lyzer.Errors;\n\nnamespace Lyzer.Clients\n{\n    public class JolpicaClient\n    {\n        private readonly ILogger&lt;JolpicaClient&gt; _logger;\n        private readonly RestClient _client;\n\n        public JolpicaClient(ILogger&lt;JolpicaClient&gt; logger)\n        {\n            RestClientOptions options = new RestClientOptions(URIConstants.Jolpica.BaseUri);\n            _client = new RestClient(options);\n            _logger = logger;\n        }\n\n        public async Task&lt;DriverStandingsDTO&gt; GetCurrentDriverStandings()\n        {\n            string requestPath = String.Format(URIConstants.Jolpica.DriverStandingsUri, \"current\");\n            JsonDocument? result = await _client.GetAsync&lt;JsonDocument&gt;(requestPath);\n\n            if (result == null)\n            {\n                throw new Exception404NotFound(\"Could not retrieve data at: \" + requestPath);\n            }\n\n            JsonElement root = result.RootElement;\n\n            JsonElement standings = root\n                .GetProperty(\"MRData\")\n                .GetProperty(\"StandingsTable\")\n                .GetProperty(\"StandingsLists\")[0];\n\n            DriverStandingsDTO? driverStandings = JsonConvert.DeserializeObject&lt;DriverStandingsDTO&gt;(standings.GetRawText());\n\n            if (driverStandings == null)\n            {\n                throw new SerializationException(\"Could not deserialize driver standings.\");\n            }\n\n            return driverStandings;\n        }\n    }\n}\n</code></pre>"},{"location":"backend/architecture/#repositories","title":"Repositories","text":"<p>Repositories are responsible for communicating with data storage such as a database (e.g., PostgreSQL). Currently, the project does not contain any repositories, but they will likely be needed in the future.</p> <p>Please note that repositories are similar to clients in that business logic and transformation should be kept to a minimum and generally avoided in these classes.</p>"},{"location":"backend/architecture/#constants","title":"Constants","text":"<p>We use classes with constants for values that are frequently used. If we make changes to these values, they should reflect across the entire codebase.</p> <p>This is easy to manage with constants, as all values using the variable will be updated.</p> <p>An example is shown below:</p> <pre><code>namespace Lyzer.Common.Constants\n{\n    public static class URIConstants\n    {\n        public static class Jolpica\n        {\n            public static string BaseUri { get; set; } = \"https://api.jolpi.ca/ergast/f1\";\n            public static string DriverStandingsUri { get; set; } = \"/{0}/driverstandings\";\n        }\n    }\n}\n</code></pre>"},{"location":"backend/architecture/#dtos","title":"DTOs","text":"<p>You might be familiar with schemas, models, or other terms for these. In this codebase, they are referred to as DTOs (Data Transfer Objects).</p> <p>These objects represent what the API will return on successful calls.</p> <p>An example is shown below:</p> <pre><code>namespace Lyzer.Common.DTO\n{\n    public class DriverDTO\n    {\n        public string DriverId { get; set; }\n        public string PermanentNumber { get; set; }\n        public string Code { get; set; }\n        public string Url { get; set; }\n        public string GivenName { get; set; }\n        public string FamilyName { get; set; }\n        public DateTime DateOfBirth { get; set; }\n        public string Nationality { get; set; }\n    }\n}\n</code></pre>"},{"location":"backend/architecture/#middleware","title":"Middleware","text":"<p>Middleware components are used to handle cross-cutting concerns such as logging, authentication, and error handling. They are executed in the order they are registered in the application pipeline.</p> <p>Currently we only use this for error handling.</p> <p>An example is shown below:</p> <pre><code>using Lyzer.Errors;\nusing Newtonsoft.Json;\n\nnamespace Lyzer.Middleware\n{\n    public class ExceptionHandlingMiddleware\n    {\n        private readonly RequestDelegate _next;\n        private readonly ILogger&lt;ExceptionHandlingMiddleware&gt; _logger;\n\n        public ExceptionHandlingMiddleware(RequestDelegate next, ILogger&lt;ExceptionHandlingMiddleware&gt; logger)\n        {\n            _next = next;\n            _logger = logger;\n        }\n\n        public async Task Invoke(HttpContext context)\n        {\n            try\n            {\n                await _next(context);\n            }\n            catch (Exception404NotFound ex)\n            {\n                _logger.LogError(ex, \"404 exception occurred.\");\n                await HandleExceptionAsync(context, StatusCodes.Status404NotFound, \"Not found.\", ex);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"An unhandled exception occurred.\");\n                await HandleExceptionAsync(context, StatusCodes.Status500InternalServerError, \"An unexpected error occurred.\", ex);\n            }\n        }\n\n        private static Task HandleExceptionAsync(HttpContext context, int statusCode, string message, Exception exception)\n        {\n            context.Response.ContentType = \"application/json\";\n            context.Response.StatusCode = statusCode;\n\n            var errorResponse = new\n            {\n                Message = message,\n                Details = exception.Message\n            };\n\n            return context.Response.WriteAsync(JsonConvert.SerializeObject(errorResponse));\n        }\n    }\n}\n</code></pre> <p>Middleware components are registered in the <code>Program.cs</code> file. For example:</p> <pre><code>var app = builder.Build();\n\napp.UseSwagger();\napp.UseSwaggerUI();\napp.UseHttpsRedirection();\napp.UseAuthorization();\napp.MapControllers();\n\napp.UseMiddleware&lt;ExceptionHandlingMiddleware&gt;();\n</code></pre>"},{"location":"backend/architecture/#errors","title":"Errors","text":"<p>Error handling is a crucial part of any application. In Lyzer, we handle errors using custom exceptions and middleware to ensure consistent and meaningful error responses.</p> <p>The middleware aspect of this was covered above, below you can find an example of a custom exception.</p> <pre><code>namespace Lyzer.Errors\n{\n    public class Exception404NotFound : Exception\n    {\n        public Exception404NotFound(string message) : base(message) { }\n    }\n}\n</code></pre>"},{"location":"backend/architecture/#diagram","title":"Diagram","text":""},{"location":"backend/caching/","title":"How We Utilize Redis for Caching","text":"<p>We use Redis as a caching solution for F1 data that is subject to change and based on the current year.</p> <p>To keep things simple, we use fixed time-to-live (TTL) caching, which may vary depending on the data being cached.</p>"},{"location":"backend/caching/#ttl-cache-for-different-datasets","title":"TTL Cache for Different Datasets","text":"<ul> <li>Races/Schedules: 24-hour TTL</li> <li>Driver Standings: 1-hour TTL</li> <li>Constructor Standings: 1-hour TTL</li> <li>Race Results: 1-hour TTL</li> </ul>"},{"location":"backend/caching/#how-we-retrieve-and-store-cached-data","title":"How We Retrieve and Store Cached Data","text":"<p>Currently, the data stored in the cache are JSON strings. These strings are serialized on the API side when setting the cache and deserialized when retrieving it.</p> <p>Below you can find an example on how we serialize/deserialize those values with C# using the CacheService we have implemented in the codebase:</p> <pre><code>public async Task&lt;DriverStandingsDTO&gt; GetCurrentDriverStandings()\n{\n    string key = String.Format(CacheKeyConstants.DriverStandings, \"current\");\n    string? result = await _cache.Get(key);\n\n    if (result == null)\n    {\n        DriverStandingsDTO standings = await _client.GetCurrentDriverStandings();\n        await _cache.Add(key, JsonConvert.SerializeObject(standings), TimeSpan.FromHours(1));\n        return standings;\n    }\n\n    return JsonConvert.DeserializeObject&lt;DriverStandingsDTO&gt;(result) ?? new DriverStandingsDTO();\n}\n</code></pre>"},{"location":"dev/","title":"Development (Getting Started)","text":"<p>Welcome to the Lyzer development environment! This guide will help you set up everything you need to start contributing to the project.</p>"},{"location":"dev/#prerequisites","title":"Prerequisites","text":"<p>Before diving into development, ensure you have the following tools installed:  </p> <ul> <li>Docker: For containerizing and managing the development environment.  </li> <li>Docker Compose: To orchestrate the various containers required for Lyzer.  </li> <li>An IDE or Editor: We recommend Visual Studio Code for its Docker and C# support, but feel free to use your preferred editor.</li> </ul> <p>Note: At this stage, only the API is ready for active development. The frontend is not yet in a functional state.  </p>"},{"location":"dev/#starting-the-development-environment","title":"Starting the Development Environment","text":"<p>Follow these steps to spin up the development environment:  </p> <ul> <li>Clone the Repository    Ensure you have the latest version of the Lyzer repository on your local machine:  </li> </ul> <pre><code>git clone https://github.com/LittleClumsy/Lyzer.git  \ncd lyzer  \n</code></pre> <ul> <li>Start the Containers in Watch Mode    Use the following command to start the Docker containers with watch mode enabled:</li> </ul> <pre><code>docker compose watch\n</code></pre> <p>The <code>watch</code> command ensures that changes to the API source code automatically trigger a rebuild for the container.  </p> <ul> <li>Verify the Environment    Once the containers are up, confirm that the API is running by navigating to its swagger docs (e.g., <code>http://localhost:8080/swagger/index.html</code>).</li> </ul>"},{"location":"dev/#development-workflow","title":"Development Workflow","text":""},{"location":"dev/#making-changes","title":"Making Changes","text":"<ul> <li>All API code is located in the <code>/Backend</code> directory.</li> <li>Save changes, and the watch mode will rebuild the application automatically.</li> </ul>"},{"location":"dev/#testing-the-api","title":"Testing the API","text":"<ul> <li>Use the swagger documentation to test the endpoints</li> <li>Or Use tools like Postman or cURL to test API endpoints.  </li> </ul>"},{"location":"dev/#troubleshooting","title":"Troubleshooting","text":""},{"location":"dev/#common-issues","title":"Common Issues","text":"<ul> <li>Port Conflicts: Ensure no other services are running on the same ports used by Lyzer.  </li> </ul>"},{"location":"dev/#getting-help","title":"Getting Help","text":"<p>If you encounter issues that you can\u2019t resolve, feel free to open an issue in the GitHub repository or reach out to the project maintainers.</p>"},{"location":"dev/architecture/","title":"High-Level Architecture Overview","text":"<p>Note: This project is under active development, so the architecture is subject to change.</p>"},{"location":"dev/architecture/#components","title":"Components","text":"<ul> <li>Jolpica F1 API</li> <li>Redis</li> <li>Lyzer API<ul> <li>C#</li> <li>ASP.NET</li> </ul> </li> </ul>"},{"location":"dev/architecture/#jolpica-f1-api","title":"Jolpica F1 API","text":"<p>The Jolpica F1 API, a successor to the Ergast F1 API, can be found here. This is currently the primary data source for all F1 data provided by Lyzer.</p>"},{"location":"dev/architecture/#redis","title":"Redis","text":"<p>We use Redis to cache data for the current year instead of storing it in a more permanent location, as this data is subject to change. Examples of cached data include:</p> <ul> <li>Driver Standings</li> <li>Constructor Standings</li> <li>Races for the season</li> </ul>"},{"location":"dev/architecture/#lyzer-api","title":"Lyzer API","text":"<p>The Lyzer API is a C#, ASP.NET powered backend. Its main roles are:</p> <ul> <li>Providing Formula 1 data for the current year such as:<ul> <li>Driver Standings</li> <li>Constructor Standings</li> <li>Races</li> <li>Results</li> </ul> </li> </ul>"},{"location":"dev/architecture/#diagram","title":"Diagram","text":""}]}